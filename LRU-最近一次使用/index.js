// 链表相关应用
// Vue中keep-alive组件
// 包裹起来的组件来回切换，可以保存组件状态避免重新渲染
// 1. 内存有限，若有大量的组件，keep-alive也是所有的都缓存嘛？
// 并不是。有设计缓存模块，只能缓存固定数量的组件，当数量过多，会淘汰部分组件，防止内存爆满。
// Vue在组件编译缓存也用到缓存，都是需要有合适的淘汰机制。
// ——————————————————————————————————————————————————————————————
// 1. 队列，先进先出 => 适合任务机制 不适合组件这种
// 进        出
// -----------
// 1 2 3 4 5 6 ->>>
// -----------
// 2. LF 计算每个数据出现次数，淘汰出现次数最少的 => 比较消耗性能需要做数据统计
// {
//   a: 1，
//   b: 3,
//   c: 2
// }
// 3. LRU cache Last Recently Use => 组件缓存  *****
// 设定最大容量，可以正常增删改，若增超过容量，则应该逐出最久未使用的关键字。
// 新鲜的定义：刚被修改(put)，或者访问过(get)，就算新鲜，就需要 splice 到链表头。
// 读取 若存在 先删除 后新增
// 新增 若存在 先删除 后新增
//      不存在 删除最早新增的值 新增
// 1 => 2 => 3 => 4
// 3 => 1 => 2 => 4
let cache = new Map(); // Map => 保存键值对，能够记住键原始插入顺序，任何值(对象或者原始值) 都可以作为一个键或一个值。
cache.set("a", 1);
cache.set("b", 2);
cache.set("c", 3);
console.log(cache);
console.log(cache.keys()); // Map Iterator
console.log(cache.keys().next());
console.log(cache.keys().next().value);
